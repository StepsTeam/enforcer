// build_helpers/create_naming_words_arrays.rs

use std::fs;
use std::io::{self, BufRead};
use std::path::PathBuf;
use std::env;

use super::Subway; // Import Subway struct from build_helpers/mod.rs

/// collect_naming_words()
/// - Reads words from `verbs.txt`, `adjectives.txt`, and `nouns.txt` located in `subway.definitions_dir`.
/// - Extracts the term before the first colon from each line.
/// - Populates `subway.function_verbs`, `subway.function_adjectives`, and `subway.function_nouns`.
/// - Returns the updated Subway struct.
fn collect_naming_words(mut subway: Subway) -> Subway {
    // Ensure definitions_dir is set, otherwise return immediately.
    let definitions_dir = match subway.definitions_dir.clone() {
        Some(dir) => dir,
        None => {
            eprintln!("Error: definitions_dir not set in Subway. Cannot collect word definitions.");
            return subway;
        }
    };

    let files_to_read = [
        ("verbs", definitions_dir.join("verbs.txt")),
        ("adjectives", definitions_dir.join("adjectives.txt")),
        ("nouns", definitions_dir.join("nouns.txt")),
    ];

    for (word_type, file_path) in files_to_read.iter() {
        let result = fs::File::open(file_path);
        let words_vec = match result {
            Ok(file) => {
                let reader = io::BufReader::new(file);
                let mut collected_words = Vec::new();
                for line in reader.lines() {
                    let line = match line {
                        Ok(l) => l,
                        Err(e) => {
                            eprintln!("Warning: Error reading line from {:?}: {}", file_path, e);
                            continue;
                        }
                    };
                    if let Some(word) = line.split(':').next() {
                        let trimmed_word = word.trim();
                        if !trimmed_word.is_empty() {
                            collected_words.push(trimmed_word.to_string());
                        }
                    }
                }
                collected_words
            },
            Err(e) => {
                eprintln!("Warning: Could not read {} from {:?}: {}", word_type, file_path, e);
                Vec::new() // Return an empty vector on file open error
            }
        };

        match *word_type {
            "verbs" => subway.function_verbs = Some(words_vec),
            "adjectives" => subway.function_adjectives = Some(words_vec),
            "nouns" => subway.function_nouns = Some(words_vec),
            _ => eprintln!("Error: Unknown word_type '{}' in collect_naming_words loop.", word_type),
        }
    }

    subway
}

/// Generates the `traintrack.toml` file with dynamic naming word arrays.
/// Reads verb, adjective, and noun definitions from external text files
/// and embeds them into the TOML structure.
pub fn create_naming_words_arrays(mut subway: Subway) -> Subway {
    println!("Building: Generating traintrack.toml with naming word arrays...");

    let current_dir = env::var("CARGO_MANIFEST_DIR")
        .expect("CARGO_MANIFEST_DIR not set");
    let definitions_dir = PathBuf::from(current_dir.clone()).join("definitions"); // FIX: Cloned current_dir here

    // Set the definitions_dir in Subway before calling the collector
    subway.definitions_dir = Some(definitions_dir.clone());

    // Collect all word definitions using the Subway-in, Subway-out helper
    subway = collect_naming_words(subway);

    // Extract the collected words from Subway using .take()
    let function_verbs = subway.function_verbs.take().unwrap_or_else(Vec::new);      // FIX: Used .take()
    let function_adjectives = subway.function_adjectives.take().unwrap_or_else(Vec::new); // FIX: Used .take()
    let function_nouns = subway.function_nouns.take().unwrap_or_else(Vec::new);    // FIX: Used .take()

    // Tell Cargo to re-run if any of the definition files change
    println!("cargo:rerun-if-changed={}", definitions_dir.join("verbs.txt").display());
    println!("cargo:rerun-if-changed={}", definitions_dir.join("adjectives.txt").display());
    println!("cargo:rerun-if-changed={}", definitions_dir.join("nouns.txt").display());

    // Generate the TOML content string
    let toml_content = format!(
        r#"# config/traintrack.toml
# This file provides configuration settings for the TrainTrack module.
# Automatically generated by build_helpers/create_naming_words_arrays.rs

[naming_conventions]
# List of recognized verbs for function names (e.g., for TT015)
function_verbs = [
    {}
]

# List of recognized adjectives for function names (e.g., for TT018)
function_adjectives = [
    {}
]

# List of recognized nouns for function names (e.g., for TT016, TT019)
function_nouns = [
    {}
]

# Enforce camelCase instead of snake_case for function names
# force_camel_case = false
"#,
        function_verbs.iter().map(|s| format!("    \"{}\"", s)).collect::<Vec<_>>().join(",\n"),
        function_adjectives.iter().map(|s| format!("    \"{}\"", s)).collect::<Vec<_>>().join(",\n"),
        function_nouns.iter().map(|s| format!("    \"{}\"", s)).collect::<Vec<_>>().join(",\n")
    );

    // Define the output path for traintrack.toml
    let config_dir = PathBuf::from(current_dir).join("config"); // Original current_dir is available here
    let output_path = config_dir.join("traintrack.toml");

    // Ensure the config directory exists
    if let Err(e) = fs::create_dir_all(&config_dir) {
        eprintln!("Error creating config directory {:?}: {}", config_dir, e);
        // Consider signaling a wreck in Subway here if this is fatal.
        return subway;
    }

    // Write the content to traintrack.toml
    if let Err(e) = fs::write(&output_path, toml_content) {
        eprintln!("Error writing traintrack.toml to {:?}: {}", output_path, e);
        // Consider signaling a wreck in Subway here if this is fatal.
        return subway;
    }

    println!("Generated traintrack.toml at: {:?}", output_path);

    subway
}
